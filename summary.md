### Переменные в Bash

**Переменные** в Bash используются для хранения данных и позволяют скрипту работать с изменяемыми значениями.

#### Объявление и присваивание переменных

- **Объявление переменной** происходит автоматически при присваивании значения без предварительного указания типа данных.

  ```bash
  variable_name="значение"
  ```

- **Примеры**:

  ```bash
  name="Иван"
  age=30
  ```

- **Правила**:

  - Имена переменных чувствительны к регистру (`var` и `VAR` — разные переменные).
  - Имя переменной не должно начинаться с цифры.
  - Не должно содержать пробелов (используйте подчеркивания `_` для разделения слов).

#### Использование переменных

- Для доступа к значению переменной используется префикс `$`.

  ```bash
  echo $variable_name
  ```

- **Примеры**:

  ```bash
  echo "Имя: $name"
  echo "Возраст: $age"
  ```

#### Виды кавычек

- **Двойные кавычки `" "`**: позволяют интерпретировать переменные и некоторые специальные символы.

  ```bash
  echo "Привет, $name!"  # Выведет значение переменной name
  ```

- **Одинарные кавычки `' '`**: подавляют интерпретацию переменных и специальных символов.

  ```bash
  echo 'Привет, $name!'  # Выведет строку с $name без замены на значение
  ```

#### Переменные окружения

- **Переменные окружения** доступны во всех процессах, порожденных текущей сессией.

- **Объявление переменной окружения**:

  ```bash
  export VARIABLE_NAME="значение"
  ```

- **Примеры часто используемых переменных окружения**:

  - `$HOME` — домашний каталог пользователя.
  - `$PATH` — список директорий для поиска исполняемых файлов.
  - `$PWD` — текущий рабочий каталог.

#### Чтение данных от пользователя

- **Команда `read`** позволяет запрашивать ввод пользователя и сохранять его в переменную.

  ```bash
  read variable_name
  ```

- **Пример**:

  ```bash
  echo "Введите ваше имя:"
  read name
  echo "Здравствуйте, $name!"
  ```

---

### Выполнение операций в Bash

#### Арифметические операции

- **Использование конструкции `$(( ))`** для выполнения арифметических операций.

  ```bash
  result=$((expression))
  ```

- **Поддерживаемые операторы**:

  - `+` — сложение
  - `-` — вычитание
  - `*` — умножение
  - `/` — целочисленное деление
  - `%` — остаток от деления
  - `**` — возведение в степень

- **Примеры**:

  ```bash
  a=10
  b=5
  sum=$((a + b))         # 15
  difference=$((a - b))  # 5
  product=$((a * b))     # 50
  quotient=$((a / b))    # 2
  remainder=$((a % b))   # 0
  power=$((a ** b))      # 100000
  ```

#### Инкремент и декремент

- **Инкремент** (увеличение на 1):

  ```bash
  ((a++))
  ```

- **Декремент** (уменьшение на 1):

  ```bash
  ((a--))
  ```

- **Примеры**:

  ```bash
  ((a += 1))  # Увеличение на 1
  ((a -= 1))  # Уменьшение на 1
  ```

#### Операции сравнения

- Используются в условных конструкциях для сравнения числовых значений.

- **Операторы**:

  - `-eq` — равно (`==`)
  - `-ne` — не равно (`!=`)
  - `-gt` — больше (`>`)
  - `-ge` — больше или равно (`>=`)
  - `-lt` — меньше (`<`)
  - `-le` — меньше или равно (`<=`)

- **Пример**:

  ```bash
  if [[ $a -gt $b ]]; then
      echo "$a больше $b"
  fi
  ```

#### Строковые операции

- **Сравнение строк**:

  - `=` — строки равны
  - `!=` — строки не равны

- **Пример**:

  ```bash
  if [[ "$str1" == "$str2" ]]; then
      echo "Строки равны"
  else
      echo "Строки не равны"
  fi
  ```

#### Логические операции

- **Логическое И**: `&&`
- **Логическое ИЛИ**: `||`
- **Логическое НЕ**: `!`

- **Пример**:

  ```bash
  if [[ $a -gt 0 && $b -gt 0 ]]; then
      echo "Оба числа положительные"
  fi
  ```

---

### Условные конструкции в Bash

#### Оператор if

- **Синтаксис**:

  ```bash
  if условие; then
      # команды, если условие истинно
  fi
  ```

- **Пример**:

  ```bash
  if [[ $a -eq 10 ]]; then
      echo "a равно 10"
  fi
  ```

#### Оператор if-else

- **Синтаксис**:

  ```bash
  if условие; then
      # команды, если условие истинно
  else
      # команды, если условие ложно
  fi
  ```

- **Пример**:

  ```bash
  if [[ $a -gt 0 ]]; then
      echo "a положительное число"
  else
      echo "a не положительное число"
  fi
  ```

#### Оператор if-elif-else

- **Синтаксис**:

  ```bash
  if условие1; then
      # команды, если условие1 истинно
  elif условие2; then
      # команды, если условие2 истинно
  else
      # команды, если ни одно из условий не истинно
  fi
  ```

- **Пример**:

  ```bash
  if [[ $a -gt 0 ]]; then
      echo "a положительное число"
  elif [[ $a -lt 0 ]]; then
      echo "a отрицательное число"
  else
      echo "a равно нулю"
  fi
  ```

#### Условные выражения

- **Числовые сравнения**:

  ```bash
  -eq  # равно
  -ne  # не равно
  -gt  # больше
  -ge  # больше или равно
  -lt  # меньше
  -le  # меньше или равно
  ```

- **Строковые сравнения**:

  ```bash
  ==   # равно
  !=   # не равно
  <    # меньше в лексикографическом порядке
  >    # больше в лексикографическом порядке
  ```

- **Проверка файлов**:

  ```bash
  -e FILE    # существует ли файл
  -f FILE    # существует ли файл и является ли обычным файлом
  -d FILE    # является ли директорией
  -s FILE    # файл существует и не пуст
  -r FILE    # доступен для чтения
  -w FILE    # доступен для записи
  -x FILE    # доступен для выполнения
  ```

- **Пример с файлами**:

  ```bash
  if [[ -f "script.sh" && -x "script.sh" ]]; then
      echo "Скрипт существует и исполняемый"
  else
      echo "Скрипт не существует или не исполняемый"
  fi
  ```

---

### Функции в Bash

#### Объявление функции

- **Синтаксис**:

  ```bash
  function имя_функции {
      # тело функции
  }
  ```

  Или без ключевого слова `function`:

  ```bash
  имя_функции() {
      # тело функции
  }
  ```

- **Пример**:

  ```bash
  greet() {
      echo "Здравствуйте!"
  }
  ```

#### Вызов функции

- **Просто указать имя функции**:

  ```bash
  greet
  ```

#### Передача аргументов в функцию

- Аргументы доступны внутри функции как `$1`, `$2`, ..., `$N`.

- **Пример**:

  ```bash
  greet() {
      echo "Здравствуйте, $1!"
  }

  greet "Иван"
  ```

#### Возврат значений из функции

- **Команда `return`** возвращает числовой статус выхода (0 — успешное выполнение).

  ```bash
  my_function() {
      # команды
      return 0
  }
  ```

- **Возврат значений через `echo`**:

  ```bash
  sum() {
      local result=$(( $1 + $2 ))
      echo $result
  }

  total=$(sum 5 7)
  echo "Сумма: $total"
  ```

#### Локальные переменные

- Объявляются с помощью ключевого слова `local`.

- **Пример**:

  ```bash
  calculate() {
      local a=$1
      local b=$2
      local sum=$((a + b))
      echo $sum
  }
  ```

#### Рекурсивные функции

- Функции могут вызывать сами себя.

- **Пример (факториал)**:

  ```bash
  factorial() {
      local n=$1
      if [[ $n -le 1 ]]; then
          echo 1
      else
          local tmp=$(( n - 1 ))
          local res=$(factorial $tmp)
          echo $(( n * res ))
      fi
  }

  result=$(factorial 5)
  echo "5! = $result"
  ```

---

### Циклы в Bash

#### Цикл for

- **Синтаксис**:

  ```bash
  for переменная in список; do
      # команды
  done
  ```

- **Пример**:

  ```bash
  for i in {1..5}; do
      echo "Итерация $i"
  done
  ```

- **Перебор файлов в директории**:

  ```bash
  for file in *.txt; do
      echo "Файл: $file"
  done
  ```

#### Цикл while

- **Синтаксис**:

  ```bash
  while условие; do
      # команды
  done
  ```

- **Пример**:

  ```bash
  count=1
  while [[ $count -le 5 ]]; do
      echo "Счетчик: $count"
      ((count++))
  done
  ```

#### Цикл until

- **Синтаксис**:

  ```bash
  until условие; do
      # команды
  done
  ```

- **Пример**:

  ```bash
  count=5
  until [[ $count -le 0 ]]; do
      echo "Обратный отсчет: $count"
      ((count--))
  done
  ```

#### Управление циклами

- **break** — немедленный выход из цикла.

  ```bash
  for i in {1..10}; do
      if [[ $i -eq 5 ]]; then
          break
      fi
      echo "i = $i"
  done
  ```

- **continue** — переход к следующей итерации.

  ```bash
  for i in {1..5}; do
      if [[ $i -eq 3 ]]; then
          continue
      fi
      echo "i = $i"
  done
  ```

---

### Работа с массивами в Bash

#### Объявление и инициализация массивов

- **Одномерные массивы**:

  ```bash
  array=(элемент1 элемент2 элемент3)
  ```

- **Присвоение значений по индексу**:

  ```bash
  array[0]="значение1"
  array[1]="значение2"
  ```

#### Доступ к элементам массива

- **Получение элемента по индексу**:

  ```bash
  echo "${array[индекс]}"
  ```

- **Пример**:

  ```bash
  echo "${array[0]}"
  ```

#### Получение всех элементов массива

- **Все элементы**:

  ```bash
  echo "${array[@]}"
  ```

- **Индексы массива**:

  ```bash
  echo "${!array[@]}"
  ```

- **Количество элементов**:

  ```bash
  echo "${#array[@]}"
  ```

#### Перебор элементов массива

- **С помощью цикла for**:

  ```bash
  for element in "${array[@]}"; do
      echo "$element"
  done
  ```

- **Перебор индексов**:

  ```bash
  for index in "${!array[@]}"; do
      echo "Элемент $index: ${array[$index]}"
  done
  ```

#### Ассоциативные массивы (Bash 4 и выше)

- **Объявление**:

  ```bash
  declare -A assoc_array
  ```

- **Присвоение значений**:

  ```bash
  assoc_array[ключ1]="значение1"
  assoc_array[ключ2]="значение2"
  ```

- **Доступ к элементам**:

  ```bash
  echo "${assoc_array[ключ1]}"
  ```

---

### Просмотр прав доступа к файлам

#### Команда `ls -l`

- Используется для отображения подробной информации о файлах и их правах.

  ```bash
  ls -l [имя_файла_или_директории]
  ```

- **Вывод**:

  ```
  -rwxr-xr-- 1 user group 4096 Oct 16 10:00 filename
  ```

#### Разбор прав доступа

- **Первый символ**: тип файла

  - `-` — обычный файл
  - `d` — директория
  - `l` — символическая ссылка

- **Следующие 9 символов**: права доступа в триады по три символа:

  - **Права владельца (user)**: символы 2-4
  - **Права группы (group)**: символы 5-7
  - **Права остальных (others)**: символы 8-10

- **Символы прав**:

  - `r` — чтение (read)
  - `w` — запись (write)
  - `x` — выполнение (execute)
  - `-` — право отсутствует

- **Пример разбора**:

  ```
  -rwxr-xr--
  | ||| |||
  | ||| |||-- Права остальных: r--
  | |||------ Права группы: r-x
  |---------- Права владельца: rwx
  ```

---

### Выдача прав доступа к файлам

#### Команда `chmod`

- Используется для изменения прав доступа к файлам и директориям.

#### Символьный метод изменения прав

- **Синтаксис**:

  ```bash
  chmod [кто][действие][права] файл
  ```

- **Кто**:

  - `u` — владелец (user)
  - `g` — группа (group)
  - `o` — остальные (others)
  - `a` — все (all)

- **Действие**:

  - `+` — добавить право
  - `-` — убрать право
  - `=` — установить точные права

- **Права**:

  - `r` — чтение
  - `w` — запись
  - `x` — выполнение

- **Примеры**:

  - **Добавить право выполнения владельцу**:

    ```bash
    chmod u+x script.sh
    ```

  - **Убрать право записи у группы**:

    ```bash
    chmod g-w file.txt
    ```

  - **Установить права чтения для всех**:

    ```bash
    chmod a=r document.txt
    ```

#### Числовой метод изменения прав

- **Синтаксис**:

  ```bash
  chmod [три_цифры] файл
  ```

- **Значения цифр**:

  - `4` — чтение (`r`)
  - `2` — запись (`w`)
  - `1` — выполнение (`x`)

- **Комбинации**:

  - `7` (`4+2+1`) — `rwx`
  - `6` (`4+2`) — `rw-`
  - `5` (`4+1`) — `r-x`
  - `0` — `---`

- **Примеры**:

  - **Установить права `rwxr-xr-x`**:

    ```bash
    chmod 755 script.sh
    ```

  - **Установить права `rw-r--r--`**:

    ```bash
    chmod 644 file.txt
    ```

#### Рекурсивное изменение прав

- **Опция `-R`** позволяет изменить права во всех вложенных файлах и директориях.

  ```bash
  chmod -R 700 my_directory
  ```

---

### Что такое и зачем нужен IP-адрес и маска подсети

#### IP-адрес

- **IP-адрес (Internet Protocol address)** — уникальный числовой идентификатор устройства в сети.

- **IPv4-адрес**:

  - Состоит из 32 бит.
  - Записывается в виде четырех десятичных чисел (октетов), разделенных точками.

    ```
    192.168.1.10
    ```

- **Назначение**:

  - Идентификация устройства в сети.
  - Обеспечение возможности передачи данных между устройствами.

#### Маска подсети

- **Маска подсети** — 32-битное число, используемое для разделения IP-адреса на часть сети и часть хоста (устройства).

- **Записывается** аналогично IP-адресу:

  ```
  255.255.255.0
  ```

- **Назначение**:

  - Определяет, какая часть IP-адреса отвечает за сеть, а какая — за хост.
  - Позволяет разделять большие сети на более мелкие (подсети).

#### Зачем нужны IP-адрес и маска подсети

- **IP-адрес** необходим для уникальной идентификации устройства в сети и для обеспечения возможности обмена данными.

- **Маска подсети** позволяет определить, к какой сети принадлежит устройство, что важно для маршрутизации пакетов данных в сетях.

#### Как это работает

1. **Разделение IP-адреса на сеть и хост**

   - **Пример**:

     - IP-адрес: `192.168.1.10`
     - Маска подсети: `255.255.255.0`

   - **Бинарное представление**:

     - IP-адрес:

       ```
       11000000.10101000.00000001.00001010
       ```

     - Маска подсети:

       ```
       11111111.11111111.11111111.00000000
       ```

   - **Часть сети**: первые 24 бита (где в маске стоят единицы).

     ```
     192.168.1.0
     ```

   - **Часть хоста**: последние 8 бит (где в маске нули).

     ```
     0.0.0.10
     ```

2. **Маршрутизация данных**

   - Устройства с IP-адресами в одной сети могут обмениваться данными напрямую.

   - Если данные нужно отправить в другую сеть, они передаются через маршрутизатор.

#### Пример использования

- **Определение, находятся ли два устройства в одной сети**:

  - **Устройство A**:

    - IP-адрес: `192.168.1.10`
    - Маска подсети: `255.255.255.0`

  - **Устройство B**:

    - IP-адрес: `192.168.1.20`
    - Маска подсети: `255.255.255.0`

  - **Результат**:

    - Часть сети у обоих устройств: `192.168.1.0`
    - Следовательно, они в одной сети и могут общаться напрямую.

#### Важность использования маски подсети

- **Оптимизация сети**: разделение на подсети снижает объем широковещательного трафика.

- **Безопасность**: изоляция сетей позволяет ограничить доступ между различными сегментами.

- **Управляемость**: упрощает администрирование больших сетей.

---
