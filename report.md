# Отчёт для ЛР2

---

## Цель задачи

Разработать bash-скрипт `ip_to_binary.sh`, который принимает на вход IPv4-адрес в десятичном формате и выводит его в двоичном формате. Скрипт должен корректно обрабатывать как стандартные, так и крайние случаи, включая проверку валидности введённого IP-адреса.

**Пример:**

При вводе команды:

```bash
bash ip_to_binary.sh 192.168.10.1
```

в терминале должно отображаться:

```
11000000.10101000.00001010.00000001
```

---

## Решение

Для достижения поставленной цели был разработан bash-скрипт `ip_to_binary.sh`, который выполняет преобразование IPv4-адреса из десятичного формата в двоичный. Скрипт включает проверку корректности введённого IP-адреса и содержит подробные комментарии к каждой строке кода для облегчения понимания его работы.

### Шаги реализации:

1. **Создание файла скрипта и предоставление прав на выполнение**

   Создайте файл с именем `ip_to_binary.sh` и добавьте к нему права на выполнение:

   ```bash
   touch ip_to_binary.sh
   chmod +x ip_to_binary.sh
   ```

2. **Добавление shebang**

   В начале файла укажите путь к bash-интерпретатору:

   ```bash
   #!/bin/bash
   ```

3. **Полный код скрипта с комментариями**

   Ниже представлен полный код скрипта `ip_to_binary.sh` с комментариями к каждой строке:

   ```bash
   #!/bin/bash

   # Проверка, что скрипт запущен с одним аргументом
   if [ $# -ne 1 ]; then
       # Если нет, вывести сообщение об использовании и выйти с кодом ошибки 1
       echo "Использование: $0 <IPv4-адрес>"
       exit 1
   fi

   # Сохранение первого аргумента в переменную 'ip'
   ip=$1

   # Проверка, что введённый IP-адрес соответствует формату x.x.x.x, где x - от 0 до 999
   if [[ ! $ip =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
       # Если формат неверен, вывести сообщение об ошибке и выйти с кодом ошибки 1
       echo "Ошибка: Некорректный формат IPv4-адреса."
       exit 1
   fi

   # Разделение IP-адреса на четыре части (октета) по точке
   IFS='.' read -r o1 o2 o3 o4 <<< "$ip"

   # Функция для проверки, что октет является числом от 0 до 255
   validate_octet() {
       local octet=$1  # Присваиваем первый аргумент функции переменной 'octet'

       # Проверка, что октет состоит только из цифр
       if ! [[ $octet =~ ^[0-9]+$ ]]; then
           # Если нет, вывести сообщение об ошибке и выйти с кодом ошибки 1
           echo "Ошибка: Октет '$octet' не является числом."
           exit 1
       fi

       # Проверка, что октет находится в диапазоне от 0 до 255
       if [ "$octet" -lt 0 ] || [ "$octet" -gt 255 ]; then
           # Если нет, вывести сообщение об ошибке и выйти с кодом ошибки 1
           echo "Ошибка: Октет '$octet' вне допустимого диапазона (0-255)."
           exit 1
       fi
   }

   # Проверка каждого октета на корректность с помощью функции validate_octet
   validate_octet "$o1"
   validate_octet "$o2"
   validate_octet "$o3"
   validate_octet "$o4"

   # Функция для преобразования десятичного числа в двоичное с ведущими нулями до 8 бит
   dec2bin() {
       local dec=$1       # Присваиваем первый аргумент функции переменной 'dec'
       local bin=""       # Инициализируем переменную 'bin' пустой строкой для хранения двоичного результата
       local pad_length=8 # Задаём необходимую длину двоичного числа (8 бит)

       # Цикл для преобразования числа из десятичного в двоичное
       while [ "$dec" -gt 0 ]; do
           bin=$((dec % 2))$bin # Добавляем остаток от деления на 2 в начало строки 'bin'
           dec=$((dec / 2))     # Делим число на 2 для следующей итерации
       done

       # Добавление ведущих нулей до достижения длины 8 бит
       while [ ${#bin} -lt $pad_length ]; do
           bin="0$bin"          # Добавляем '0' в начало строки 'bin'
       done

       echo "$bin" # Вывод двоичного числа
   }

   # Преобразование каждого октета из десятичного в двоичный формат с помощью функции dec2bin
   b1=$(dec2bin "$o1") # Преобразование первого октета
   b2=$(dec2bin "$o2") # Преобразование второго октета
   b3=$(dec2bin "$o3") # Преобразование третьего октета
   b4=$(dec2bin "$o4") # Преобразование четвертого октета

   # Вывод результата в формате xxxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx
   echo "$b1.$b2.$b3.$b4"
   ```

---

## Объяснение работы скрипта

### Общая структура

1. **Shebang (`#!/bin/bash`):**
   - Указывает системе, что скрипт должен выполняться с использованием bash-интерпретатора.

2. **Проверка количества аргументов:**
   - `if [ $# -ne 1 ]; then`: Проверяет, что количество переданных аргументов не равно 1.
   - Если условие истинно, выводится сообщение об использовании скрипта и скрипт завершается с кодом ошибки `1`.

3. **Сохранение аргумента:**
   - `ip=$1`: Присваивает переменной `ip` значение первого аргумента командной строки.

4. **Проверка формата IP-адреса:**
   - `if [[ ! $ip =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then`: Использует регулярное выражение для проверки, что IP-адрес состоит из четырёх чисел (от 1 до 3 цифр), разделённых точками.
   - Если формат некорректен, выводится сообщение об ошибке и скрипт завершается.

5. **Разделение IP-адреса на октеты:**
   - `IFS='.' read -r o1 o2 o3 o4 <<< "$ip"`: Разделяет строку `ip` на четыре части по точке и сохраняет их в переменные `o1`, `o2`, `o3`, `o4`.

6. **Функция `validate_octet`:**
   - **Описание:**
     - Проверяет, что переданный октет является числом и находится в диапазоне от 0 до 255.
   - **Структура:**
     - `local octet=$1`: Присваивает локальной переменной `octet` значение первого аргумента функции.
     - `if ! [[ $octet =~ ^[0-9]+$ ]]; then`: Проверяет, что октет состоит только из цифр.
     - `echo "Ошибка: Октет '$octet' не является числом."`: Выводит сообщение об ошибке, если октет не является числом.
     - `exit 1`: Завершает выполнение скрипта с кодом ошибки `1`.
     - `if [ "$octet" -lt 0 ] || [ "$octet" -gt 255 ]; then`: Проверяет, что октет находится в диапазоне от 0 до 255.
     - `echo "Ошибка: Октет '$octet' вне допустимого диапазона (0-255)."`: Выводит сообщение об ошибке, если октет вне допустимого диапазона.
     - `exit 1`: Завершает выполнение скрипта с кодом ошибки `1`.

7. **Проверка каждого октета:**
   - `validate_octet "$o1"`, `validate_octet "$o2"`, `validate_octet "$o3"`, `validate_octet "$o4"`: Вызывает функцию проверки для каждого из четырёх октетов, чтобы убедиться в их корректности.

8. **Функция `dec2bin`:**
   - **Описание:**
     - Преобразует десятичное число в двоичное, добавляя ведущие нули до 8 бит.
   - **Структура:**
     - `local dec=$1`: Присваивает локальной переменной `dec` значение первого аргумента функции.
     - `local bin=""`: Инициализирует переменную `bin` как пустую строку для хранения двоичного представления.
     - `local pad_length=8`: Устанавливает длину, до которой необходимо дополнить двоичное число ведущими нулями.
     - `while [ "$dec" -gt 0 ]; do`: Цикл выполняется, пока `dec` больше 0.
       - `bin=$((dec % 2))$bin`: Вычисляет остаток от деления на 2 и добавляет его в начало строки `bin`.
       - `dec=$((dec / 2))`: Делит `dec` на 2 с округлением вниз.
     - `while [ ${#bin} -lt $pad_length ]; do`: Цикл выполняется, пока длина строки `bin` меньше 8.
       - `bin="0$bin"`: Добавляет ведущий ноль к строке `bin`.
     - `echo "$bin"`: Выводит двоичное представление числа с ведущими нулями.

9. **Преобразование октетов в двоичный формат:**
   - `b1=$(dec2bin "$o1")`, `b2=$(dec2bin "$o2")`, `b3=$(dec2bin "$o3")`, `b4=$(dec2bin "$o4")`: Применяет функцию `dec2bin` к каждому из четырёх октетов и сохраняет результат в соответствующие переменные `b1`, `b2`, `b3`, `b4`.

10. **Вывод результата:**
    - `echo "$b1.$b2.$b3.$b4"`: Объединяет двоичные представления каждого октета через точки и выводит итоговый двоичный IP-адрес.

---

## Проверка работы скрипта

### Пример 1: Корректный IP-адрес

**Команда:**

```bash
bash ip_to_binary.sh 192.168.10.1
```

**Вывод:**

```
11000000.10101000.00001010.00000001
```

**Объяснение:**
- Скрипт успешно преобразовал каждый октет IP-адреса из десятичного в двоичный формат.

---

### Пример 2: IP-адрес с октетом вне диапазона

**Команда:**

```bash
bash ip_to_binary.sh 256.100.50.25
```

**Вывод:**

```
Ошибка: Октет '256' вне допустимого диапазона (0-255).
```

**Объяснение:**
- Скрипт обнаружил, что первый октет `256` превышает допустимый диапазон (0-255) и вывел соответствующее сообщение об ошибке.

---

### Пример 3: IP-адрес с нечисловыми символами

**Команда:**

```bash
bash ip_to_binary.sh 192.168.one.1
```

**Вывод:**

```
Ошибка: Октет 'one' не является числом.
```

**Объяснение:**
- Скрипт обнаружил, что третий октет содержит нечисловые символы (`one`) и вывел соответствующее сообщение об ошибке.

---

### Пример 4: IP-адрес с неправильным количеством октетов

**Команда:**

```bash
bash ip_to_binary.sh 192.168.1
```

**Вывод:**

```
Ошибка: Некорректный формат IPv4-адреса.
```

**Объяснение:**
- Скрипт обнаружил, что IP-адрес содержит только три октета вместо четырёх и вывел сообщение об ошибке некорректного формата.

---

### Пример 5: Запуск без аргументов

**Команда:**

```bash
bash ip_to_binary.sh
```

**Вывод:**

```
Использование: ./ip_to_binary.sh <IPv4-адрес>
```

**Объяснение:**
- Скрипт проверил количество аргументов, обнаружил отсутствие необходимого аргумента и вывел инструкцию по использованию.

---

### Пример 6: IP-адрес с дополнительными символами

**Команда:**

```bash
bash ip_to_binary.sh 192.168.10.1.5
```

**Вывод:**

```
Ошибка: Некорректный формат IPv4-адреса.
```

**Объяснение:**
- Скрипт обнаружил наличие пятого октета, что нарушает формат IPv4-адреса, и вывел сообщение об ошибке.

---

## Заключение

В ходе выполнения лабораторной работы был разработан и протестирован bash-скрипт `ip_to_binary.sh`, который успешно преобразует IPv4-адрес из десятичного формата в двоичный. Скрипт включает механизмы валидации ввода, обеспечивая корректную работу как с обычными, так и с некорректными или крайними случаями.

**Ключевые особенности скрипта:**

- **Валидация формата IP-адреса:** Проверяет, что введённый адрес состоит из четырёх октетов, разделённых точками, и каждый октет содержит от 1 до 3 цифр.
- **Проверка диапазона октетов:** Убеждается, что каждый октет находится в диапазоне от 0 до 255.
- **Преобразование в двоичный формат:** Конвертирует каждый октет в двоичный формат с ведущими нулями до 8 бит.
- **Подробные комментарии:** Каждая строка кода снабжена комментариями для облегчения понимания работы скрипта.

**Возможные улучшения:**

- **Расширенная валидация:** Добавить проверку на отсутствие ведущих нулей в октетах (например, `01` вместо `1`), если это необходимо.
- **Обработка дополнительных форматов:** Расширить функциональность скрипта для поддержки других форматов IP-адресов или масок подсети.
- **Оптимизация функции преобразования:** Использовать встроенные средства bash или другие утилиты для более эффективного преобразования чисел, что может повысить производительность скрипта при обработке большого количества адресов.

Данные улучшения могут повысить надёжность и универсальность скрипта, делая его более полезным для практического применения в сетевых настройках и анализе.

---

**Дополнительные источники:**

- **Bash Scripting:**
  - [Присваивание значений переменным](https://tldp.org/LDP/abs/html/assignments.html)
  - [Условные операторы](https://tldp.org/LDP/abs/html/testconstructs.html)
  - [Циклы](https://tldp.org/LDP/abs/html/loops.html)
  - [Функции](https://tldp.org/LDP/abs/html/functions.html)
  - [Массивы](https://tldp.org/LDP/abs/html/arrays.html)

- **Сетевые технологии:**
  - В. Олифер, Н. Олифер "Компьютерные сети. Принципы, технологии, протоколы. Учебник" (2016)

---
